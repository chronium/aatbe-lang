const SCREEN: i32 = 0xB8000
const WIDTH: i32 = 80
const HEIGHT: i32 = 25

rec Term(x: i32, y: i32, color: i8)

fn strlen s: str -> i32 = {
    var len = 0
    while s[len] as i8 != 0i8 {
        len = len + 1
    }
    len
}

fn putc term: &Term, c: char = {
    var screen = SCREEN as str

    if c as i8 == 10i8 {
        term.x = 0
        term.y = term.y + 1

        ()
    } else {
        val index = (term.x + term.y * WIDTH) * 2
        screen[index] = c
        screen[index + 1] = 31i8 as char

        term.x = term.x + 1
        ()
    }
}

fn puts term: &Term, s: str = {
    var i = 0
    while i < (strlen s) {
        putc &term, s[i]
        i = i + 1
    }
}

fn clear_row row: i32 = {
    var screen = SCREEN as str
    var index = row * WIDTH * 2
    var i = 0

    while i < WIDTH {
        screen[index] = ' '
        screen[index + 1] = 31i8 as char

        index = index + 2
        i = i + 1
    }
}

fn cls () = {
    var i = 0

    while i < WIDTH {
        clear_row i
        i = i + 1
    }
}

@entry
fn kern_main () = {
    cls ()

    var term = Term {
        x: 0,
        y: 0,
        color: 31i8
    }

    puts &term, "Hello World from Aatbe!\nThis is the first fun thing.\n"
    puts &term, "This is very surprising that it works."
}
